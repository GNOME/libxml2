<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>tree</title><meta name="generator" content="DocBook XSL Stylesheets V1.48"><meta name="generator" content="GTK-Doc V1.1 (XML mode)"><style type="text/css">
        .synopsis, .classsynopsis {
            background: #eeeeee;
            border: solid 1px #aaaaaa;
            padding: 0.5em;
        }
        .programlisting {
            background: #eeeeff;
            border: solid 1px #aaaaff;
            padding: 0.5em;
        }
        .variablelist {
            padding: 4px;
            margin-left: 3em;
        }
        .navigation {
            background: #ffeeee;
            border: solid 1px #ffaaaa;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }
        .navigation a {
            color: #770000;
        }
        .navigation a:visited {
            color: #550000;
        }
        .navigation .title {
            font-size: 200%;
        }
      </style><link rel="home" href="index.html" title="Gnome XML Library Reference Manual "><link rel="up" href="ch01.html" title="Libxml Programming Notes"><link rel="previous" href="libxml-catalog.html" title="catalog"><link rel="next" href="libxml-globals.html" title="globals"></head><body text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table class="navigation" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2"><tr valign="middle"><td><a accesskey="p" href="libxml-catalog.html"><img src="left.png" width="24" height="24" border="0" alt="Prev"></a></td><td><a accesskey="u" href="ch01.html"><img src="up.png" width="24" height="24" border="0" alt="Up"></a></td><td><a accesskey="h" href="index.html"><img src="home.png" width="24" height="24" border="0" alt="Home"></a></td><th width="100%" align="center">Gnome XML Library Reference Manual </th><td><a accesskey="n" href="libxml-globals.html"><img src="right.png" width="24" height="24" border="0" alt="Next"></a></td></tr></table><div class="refentry"><a name="libxml-tree"></a><div class="titlepage"></div><div class="refnamediv"><h2>tree</h2><p>tree &#8212; </p></div><div class="refsynopsisdiv"><h2><h1 class="title"><a name="id2661507"></a>Synopsis</h1></h2><pre class="synopsis">



struct      <a href="libxml-xmlIO.html#xmlParserInputBuffer">xmlParserInputBuffer</a>;
typedef     <a href="libxml-tree.html#xmlParserInputBufferPtr">xmlParserInputBufferPtr</a>;
struct      <a href="libxml-xmlIO.html#xmlOutputBuffer">xmlOutputBuffer</a>;
typedef     <a href="libxml-tree.html#xmlOutputBufferPtr">xmlOutputBufferPtr</a>;
struct      <a href="libxml-parser.html#xmlParserInput">xmlParserInput</a>;
typedef     <a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a>;
struct      <a href="libxml-parser.html#xmlParserCtxt">xmlParserCtxt</a>;
typedef     <a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a>;
struct      <a href="libxml-parser.html#xmlSAXLocator">xmlSAXLocator</a>;
typedef     <a href="libxml-tree.html#xmlSAXLocatorPtr">xmlSAXLocatorPtr</a>;
struct      <a href="libxml-parser.html#xmlSAXHandler">xmlSAXHandler</a>;
typedef     <a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a>;
struct      <a href="libxml-entities.html#xmlEntity">xmlEntity</a>;
typedef     <a href="libxml-tree.html#xmlEntityPtr">xmlEntityPtr</a>;
#define     <a href="libxml-tree.html#BASE-BUFFER-SIZE-CAPS">BASE_BUFFER_SIZE</a>
#define     <a href="libxml-tree.html#XML-XML-NAMESPACE-CAPS">XML_XML_NAMESPACE</a>
enum        <a href="libxml-tree.html#xmlElementType">xmlElementType</a>;
typedef     <a href="libxml-tree.html#xmlChar">xmlChar</a>;
#define     <a href="libxml-tree.html#BAD-CAST-CAPS">BAD_CAST</a>
struct      <a href="libxml-tree.html#xmlNotation">xmlNotation</a>;
typedef     <a href="libxml-tree.html#xmlNotationPtr">xmlNotationPtr</a>;
enum        <a href="libxml-tree.html#xmlAttributeType">xmlAttributeType</a>;
enum        <a href="libxml-tree.html#xmlAttributeDefault">xmlAttributeDefault</a>;
struct      <a href="libxml-tree.html#xmlEnumeration">xmlEnumeration</a>;
typedef     <a href="libxml-tree.html#xmlEnumerationPtr">xmlEnumerationPtr</a>;
struct      <a href="libxml-tree.html#xmlAttribute">xmlAttribute</a>;
typedef     <a href="libxml-tree.html#xmlAttributePtr">xmlAttributePtr</a>;
enum        <a href="libxml-tree.html#xmlElementContentType">xmlElementContentType</a>;
enum        <a href="libxml-tree.html#xmlElementContentOccur">xmlElementContentOccur</a>;
struct      <a href="libxml-tree.html#xmlElementContent">xmlElementContent</a>;
typedef     <a href="libxml-tree.html#xmlElementContentPtr">xmlElementContentPtr</a>;
enum        <a href="libxml-tree.html#xmlElementTypeVal">xmlElementTypeVal</a>;
struct      <a href="libxml-tree.html#xmlElement">xmlElement</a>;
typedef     <a href="libxml-tree.html#xmlElementPtr">xmlElementPtr</a>;
#define     <a href="libxml-tree.html#XML-LOCAL-NAMESPACE-CAPS">XML_LOCAL_NAMESPACE</a>
typedef     <a href="libxml-tree.html#xmlNsType">xmlNsType</a>;
struct      <a href="libxml-tree.html#xmlNs">xmlNs</a>;
typedef     <a href="libxml-tree.html#xmlNsPtr">xmlNsPtr</a>;
struct      <a href="libxml-tree.html#xmlDtd">xmlDtd</a>;
typedef     <a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a>;
struct      <a href="libxml-tree.html#xmlAttr">xmlAttr</a>;
typedef     <a href="libxml-tree.html#xmlAttrPtr">xmlAttrPtr</a>;
struct      <a href="libxml-tree.html#xmlID">xmlID</a>;
typedef     <a href="libxml-tree.html#xmlIDPtr">xmlIDPtr</a>;
struct      <a href="libxml-tree.html#xmlRef">xmlRef</a>;
typedef     <a href="libxml-tree.html#xmlRefPtr">xmlRefPtr</a>;
enum        <a href="libxml-tree.html#xmlBufferAllocationScheme">xmlBufferAllocationScheme</a>;
struct      <a href="libxml-tree.html#xmlBuffer">xmlBuffer</a>;
typedef     <a href="libxml-tree.html#xmlBufferPtr">xmlBufferPtr</a>;
struct      <a href="libxml-tree.html#xmlNode">xmlNode</a>;
typedef     <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a>;
#define     <a href="libxml-tree.html#XML-GET-CONTENT-CAPS">XML_GET_CONTENT</a>                 (n)
#define     <a href="libxml-tree.html#XML-GET-LINE-CAPS">XML_GET_LINE</a>                    (n)
struct      <a href="libxml-tree.html#xmlDoc">xmlDoc</a>;
typedef     <a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>;
#define     <a href="libxml-tree.html#xmlChildrenNode">xmlChildrenNode</a>
#define     <a href="libxml-tree.html#xmlRootNode">xmlRootNode</a>
</pre></div><div class="refsect1"><h2>Description</h2><p>

</p></div><div class="refsect1"><h2>Details</h2><div class="refsect2"><h3><a name="xmlParserInputBuffer"></a>struct xmlParserInputBuffer</h3><pre class="programlisting">struct xmlParserInputBuffer {

    void*                  context;
    xmlInputReadCallback   readcallback;
    xmlInputCloseCallback  closecallback;
    
    xmlCharEncodingHandlerPtr encoder; /* I18N conversions to UTF-8 */
    
    xmlBufferPtr buffer;    /* Local buffer encoded in UTF-8 */
    xmlBufferPtr raw;       /* if encoder != NULL buffer for raw input */
    int	compressed;	    /* -1=unknown, 0=not compressed, 1=compressed */
    int error;
};
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlParserInputBufferPtr"></a>xmlParserInputBufferPtr</h3><pre class="programlisting">typedef xmlParserInputBuffer *xmlParserInputBufferPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlOutputBuffer"></a>struct xmlOutputBuffer</h3><pre class="programlisting">struct xmlOutputBuffer {

    void*                   context;
    xmlOutputWriteCallback  writecallback;
    xmlOutputCloseCallback  closecallback;
    
    xmlCharEncodingHandlerPtr encoder; /* I18N conversions to UTF-8 */
    
    xmlBufferPtr buffer;    /* Local buffer encoded in UTF-8 or ISOLatin */
    xmlBufferPtr conv;      /* if encoder != NULL buffer for output */
    int written;            /* total number of byte written */
    int error;
};
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlOutputBufferPtr"></a>xmlOutputBufferPtr</h3><pre class="programlisting">typedef xmlOutputBuffer *xmlOutputBufferPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlParserInput"></a>struct xmlParserInput</h3><pre class="programlisting">struct xmlParserInput {

    /* Input buffer */
    xmlParserInputBufferPtr buf;      /* UTF-8 encoded buffer */

    const char *filename;             /* The file analyzed, if any */
    const char *directory;            /* the directory/base of the file */
    const xmlChar *base;              /* Base of the array to parse */
    const xmlChar *cur;               /* Current char being parsed */
    const xmlChar *end;               /* end of the array to parse */
    int length;                       /* length if known */
    int line;                         /* Current line */
    int col;                          /* Current column */
    /*
     * NOTE: consumed is only tested for equality in the parser code,
     *       so even if there is an overflow this should not give troubles
     *       for parsing very large instances.
     */
    unsigned long consumed;           /* How many xmlChars already consumed */
    xmlParserInputDeallocate free;    /* function to deallocate the base */
    const xmlChar *encoding;          /* the encoding string for entity */
    const xmlChar *version;           /* the version string for entity */
    int standalone;                   /* Was that entity marked standalone */
    int id;                           /* an unique identifier for the entity */
};
</pre><p>
An xmlParserInput is an input flow for the XML processor.
Each entity parsed is associated an xmlParserInput (except the
few predefined ones). This is the case both for internal entities
- in which case the flow is already completely in memory - or
external entities - in which case we use the buf structure for
progressive reading and I18N conversions to the internal UTF-8 format.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlParserInputPtr"></a>xmlParserInputPtr</h3><pre class="programlisting">typedef xmlParserInput *xmlParserInputPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlParserCtxt"></a>struct xmlParserCtxt</h3><pre class="programlisting">struct xmlParserCtxt {

    struct _xmlSAXHandler *sax;       /* The SAX handler */
    void            *userData;        /* For SAX interface only, used by DOM build */
    xmlDocPtr           myDoc;        /* the document being built */
    int            wellFormed;        /* is the document well formed */
    int       replaceEntities;        /* shall we replace entities ? */
    const xmlChar    *version;        /* the XML version string */
    const xmlChar   *encoding;        /* the declared encoding, if any */
    int            standalone;        /* standalone document */
    int                  html;        /* an HTML(1)/Docbook(2) document */

    /* Input stream stack */
    xmlParserInputPtr  input;         /* Current input stream */
    int                inputNr;       /* Number of current input streams */
    int                inputMax;      /* Max number of input streams */
    xmlParserInputPtr *inputTab;      /* stack of inputs */

    /* Node analysis stack only used for DOM building */
    xmlNodePtr         node;          /* Current parsed Node */
    int                nodeNr;        /* Depth of the parsing stack */
    int                nodeMax;       /* Max depth of the parsing stack */
    xmlNodePtr        *nodeTab;       /* array of nodes */

    int record_info;                  /* Whether node info should be kept */
    xmlParserNodeInfoSeq node_seq;    /* info about each node parsed */

    int errNo;                        /* error code */

    int     hasExternalSubset;        /* reference and external subset */
    int             hasPErefs;        /* the internal subset has PE refs */
    int              external;        /* are we parsing an external entity */

    int                 valid;        /* is the document valid */
    int              validate;        /* shall we try to validate ? */
    xmlValidCtxt        vctxt;        /* The validity context */

    xmlParserInputState instate;      /* current type of input */
    int                 token;        /* next char look-ahead */    

    char           *directory;        /* the data directory */

    /* Node name stack */
    const xmlChar     *name;          /* Current parsed Node */
    int                nameNr;        /* Depth of the parsing stack */
    int                nameMax;       /* Max depth of the parsing stack */
    const xmlChar *   *nameTab;       /* array of nodes */

    long               nbChars;       /* number of xmlChar processed */
    long            checkIndex;       /* used by progressive parsing lookup */
    int             keepBlanks;       /* ugly but ... */
    int             disableSAX;       /* SAX callbacks are disabled */
    int               inSubset;       /* Parsing is in int 1/ext 2 subset */
    const xmlChar *    intSubName;    /* name of subset */
    xmlChar *          extSubURI;     /* URI of external subset */
    xmlChar *          extSubSystem;  /* SYSTEM ID of external subset */

    /* xml:space values */
    int *              space;         /* Should the parser preserve spaces */
    int                spaceNr;       /* Depth of the parsing stack */
    int                spaceMax;      /* Max depth of the parsing stack */
    int *              spaceTab;      /* array of space infos */

    int                depth;         /* to prevent entity substitution loops */
    xmlParserInputPtr  entity;        /* used to check entities boundaries */
    int                charset;       /* encoding of the in-memory content
				         actually an xmlCharEncoding */
    int                nodelen;       /* Those two fields are there to */
    int                nodemem;       /* Speed up large node parsing */
    int                pedantic;      /* signal pedantic warnings */
    void              *_private;      /* For user data, libxml won't touch it */

    int                loadsubset;    /* should the external subset be loaded */
    int                linenumbers;   /* set line number in element content */
    void              *catalogs;       /* document's own catalog */
    int                recovery;      /* run in recovery mode */
    int                progressive;   /* is this a progressive parsing */
    xmlDictPtr         dict;          /* dictionnary for the parser */
    const xmlChar *   *atts;          /* array for the attributes callbacks */
    int                maxatts;       /* the size of the array */
    int                docdict;       /* use strings from dict to build tree */

    /*
     * pre-interned strings
     */
    const xmlChar *str_xml;
    const xmlChar *str_xmlns;
    const xmlChar *str_xml_ns;

    /*
     * Everything below is used only by the new SAX mode
     */
    int                sax2;          /* operating in the new SAX mode */
    int                nsNr;          /* the number of inherited namespaces */
    int                nsMax;         /* the size of the arrays */
    const xmlChar *   *nsTab;         /* the array of prefix/namespace name */
    int               *attallocs;     /* which attribute were allocated */
    void *            *pushTab;       /* array of data for push */
    xmlHashTablePtr    attsDefault;   /* defaulted attributes if any */
    xmlHashTablePtr    attsSpecial;   /* non-CDATA attributes if any */
    int                nsWellFormed;  /* is the document XML Nanespace okay */
    int                options;       /* Extra options */

    /*
     * Those fields are needed only for treaming parsing so far
     */
    int               dictNames;    /* Use dictionary names for the tree */
    int               freeElemsNr;  /* number of freed element nodes */
    xmlNodePtr        freeElems;    /* List of freed element nodes */
    int               freeAttrsNr;  /* number of freed attributes nodes */
    xmlAttrPtr        freeAttrs;    /* List of freed attributes nodes */

    /*
     * the complete error informations for the last error.
     */
    xmlError          lastError;
};
</pre><p>
The parser context.
NOTE This doesn't completely define the parser state, the (current ?)
     design of the parser uses recursive function calls since this allow
     and easy mapping from the production rules of the specification
     to the actual code. The drawback is that the actual function call
     also reflect the parser state. However most of the parsing routines
     takes as the only argument the parser context pointer, so migrating
     to a state based parser for progressive parsing shouldn't be too hard.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlParserCtxtPtr"></a>xmlParserCtxtPtr</h3><pre class="programlisting">typedef xmlParserCtxt *xmlParserCtxtPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlSAXLocator"></a>struct xmlSAXLocator</h3><pre class="programlisting">struct xmlSAXLocator {

    const xmlChar *(*getPublicId)(void *ctx);
    const xmlChar *(*getSystemId)(void *ctx);
    int (*getLineNumber)(void *ctx);
    int (*getColumnNumber)(void *ctx);
};
</pre><p>
A SAX Locator.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlSAXLocatorPtr"></a>xmlSAXLocatorPtr</h3><pre class="programlisting">typedef xmlSAXLocator *xmlSAXLocatorPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlSAXHandler"></a>struct xmlSAXHandler</h3><pre class="programlisting">struct xmlSAXHandler {

    internalSubsetSAXFunc internalSubset;
    isStandaloneSAXFunc isStandalone;
    hasInternalSubsetSAXFunc hasInternalSubset;
    hasExternalSubsetSAXFunc hasExternalSubset;
    resolveEntitySAXFunc resolveEntity;
    getEntitySAXFunc getEntity;
    entityDeclSAXFunc entityDecl;
    notationDeclSAXFunc notationDecl;
    attributeDeclSAXFunc attributeDecl;
    elementDeclSAXFunc elementDecl;
    unparsedEntityDeclSAXFunc unparsedEntityDecl;
    setDocumentLocatorSAXFunc setDocumentLocator;
    startDocumentSAXFunc startDocument;
    endDocumentSAXFunc endDocument;
    startElementSAXFunc startElement;
    endElementSAXFunc endElement;
    referenceSAXFunc reference;
    charactersSAXFunc characters;
    ignorableWhitespaceSAXFunc ignorableWhitespace;
    processingInstructionSAXFunc processingInstruction;
    commentSAXFunc comment;
    warningSAXFunc warning;
    errorSAXFunc error;
    fatalErrorSAXFunc fatalError; /* unused error() get all the errors */
    getParameterEntitySAXFunc getParameterEntity;
    cdataBlockSAXFunc cdataBlock;
    externalSubsetSAXFunc externalSubset;
    unsigned int initialized;
    /* The following fields are extensions available only on version 2 */
    void *_private;
    startElementNsSAX2Func startElementNs;
    endElementNsSAX2Func endElementNs;
    xmlStructuredErrorFunc serror;
};
</pre><p>
A SAX handler is bunch of callbacks called by the parser when processing
of the input generate data or structure informations.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlSAXHandlerPtr"></a>xmlSAXHandlerPtr</h3><pre class="programlisting">typedef xmlSAXHandler *xmlSAXHandlerPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlEntity"></a>struct xmlEntity</h3><pre class="programlisting">struct xmlEntity {

    void           *_private;	        /* application data */
    xmlElementType          type;       /* XML_ENTITY_DECL, must be second ! */
    const xmlChar          *name;	/* Entity name */
    struct _xmlNode    *children;	/* First child link */
    struct _xmlNode        *last;	/* Last child link */
    struct _xmlDtd       *parent;	/* -&gt; DTD */
    struct _xmlNode        *next;	/* next sibling link  */
    struct _xmlNode        *prev;	/* previous sibling link  */
    struct _xmlDoc          *doc;       /* the containing document */

    xmlChar                *orig;	/* content without ref substitution */
    xmlChar             *content;	/* content or ndata if unparsed */
    int                   length;	/* the content length */
    xmlEntityType          etype;	/* The entity type */
    const xmlChar    *ExternalID;	/* External identifier for PUBLIC */
    const xmlChar      *SystemID;	/* URI for a SYSTEM or PUBLIC Entity */

    struct _xmlEntity     *nexte;	/* unused */
    const xmlChar           *URI;	/* the full URI as computed */
    int                    owner;	/* does the entity own the childrens */
};
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlEntityPtr"></a>xmlEntityPtr</h3><pre class="programlisting">typedef xmlEntity *xmlEntityPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="BASE-BUFFER-SIZE-CAPS"></a>BASE_BUFFER_SIZE</h3><pre class="programlisting">#define BASE_BUFFER_SIZE 4096
</pre><p>
default buffer size 4000.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="XML-XML-NAMESPACE-CAPS"></a>XML_XML_NAMESPACE</h3><pre class="programlisting">#define     XML_XML_NAMESPACE</pre><p>
This is the namespace for the special xml: prefix predefined in the
XML Namespace specification.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlElementType"></a>enum xmlElementType</h3><pre class="programlisting">typedef enum {
    XML_ELEMENT_NODE=		1,
    XML_ATTRIBUTE_NODE=		2,
    XML_TEXT_NODE=		3,
    XML_CDATA_SECTION_NODE=	4,
    XML_ENTITY_REF_NODE=	5,
    XML_ENTITY_NODE=		6,
    XML_PI_NODE=		7,
    XML_COMMENT_NODE=		8,
    XML_DOCUMENT_NODE=		9,
    XML_DOCUMENT_TYPE_NODE=	10,
    XML_DOCUMENT_FRAG_NODE=	11,
    XML_NOTATION_NODE=		12,
    XML_HTML_DOCUMENT_NODE=	13,
    XML_DTD_NODE=		14,
    XML_ELEMENT_DECL=		15,
    XML_ATTRIBUTE_DECL=		16,
    XML_ENTITY_DECL=		17,
    XML_NAMESPACE_DECL=		18,
    XML_XINCLUDE_START=		19,
    XML_XINCLUDE_END=		20
#ifdef LIBXML_DOCB_ENABLED
   ,XML_DOCB_DOCUMENT_NODE=	21
#endif
} xmlElementType;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlChar"></a>xmlChar</h3><pre class="programlisting">typedef unsigned char xmlChar;
</pre><p>
This is a basic byte in an UTF-8 encoded string.
It's unsigned allowing to pinpoint case where char * are assigned
to xmlChar * (possibly making serialization back impossible).</p><p>

</p></div><hr><div class="refsect2"><h3><a name="BAD-CAST-CAPS"></a>BAD_CAST</h3><pre class="programlisting">#define BAD_CAST (xmlChar *)
</pre><p>
Macro to cast a string to an xmlChar * when one know its safe.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlNotation"></a>struct xmlNotation</h3><pre class="programlisting">struct xmlNotation {

    const xmlChar               *name;	        /* Notation name */
    const xmlChar               *PublicID;	/* Public identifier, if any */
    const xmlChar               *SystemID;	/* System identifier, if any */
};
</pre><p>
A DTD Notation definition.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlNotationPtr"></a>xmlNotationPtr</h3><pre class="programlisting">typedef xmlNotation *xmlNotationPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlAttributeType"></a>enum xmlAttributeType</h3><pre class="programlisting">typedef enum {
    XML_ATTRIBUTE_CDATA = 1,
    XML_ATTRIBUTE_ID,
    XML_ATTRIBUTE_IDREF	,
    XML_ATTRIBUTE_IDREFS,
    XML_ATTRIBUTE_ENTITY,
    XML_ATTRIBUTE_ENTITIES,
    XML_ATTRIBUTE_NMTOKEN,
    XML_ATTRIBUTE_NMTOKENS,
    XML_ATTRIBUTE_ENUMERATION,
    XML_ATTRIBUTE_NOTATION
} xmlAttributeType;
</pre><p>
A DTD Attribute type definition.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlAttributeDefault"></a>enum xmlAttributeDefault</h3><pre class="programlisting">typedef enum {
    XML_ATTRIBUTE_NONE = 1,
    XML_ATTRIBUTE_REQUIRED,
    XML_ATTRIBUTE_IMPLIED,
    XML_ATTRIBUTE_FIXED
} xmlAttributeDefault;
</pre><p>
A DTD Attribute default definition.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlEnumeration"></a>struct xmlEnumeration</h3><pre class="programlisting">struct xmlEnumeration {

    struct _xmlEnumeration    *next;	/* next one */
    const xmlChar            *name;	/* Enumeration name */
};
</pre><p>
List structure used when there is an enumeration in DTDs.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlEnumerationPtr"></a>xmlEnumerationPtr</h3><pre class="programlisting">typedef xmlEnumeration *xmlEnumerationPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlAttribute"></a>struct xmlAttribute</h3><pre class="programlisting">struct xmlAttribute {

    void           *_private;	        /* application data */
    xmlElementType          type;       /* XML_ATTRIBUTE_DECL, must be second ! */
    const xmlChar          *name;	/* Attribute name */
    struct _xmlNode    *children;	/* NULL */
    struct _xmlNode        *last;	/* NULL */
    struct _xmlDtd       *parent;	/* -&gt; DTD */
    struct _xmlNode        *next;	/* next sibling link  */
    struct _xmlNode        *prev;	/* previous sibling link  */
    struct _xmlDoc          *doc;       /* the containing document */

    struct _xmlAttribute  *nexth;	/* next in hash table */
    xmlAttributeType       atype;	/* The attribute type */
    xmlAttributeDefault      def;	/* the default */
    const xmlChar  *defaultValue;	/* or the default value */
    xmlEnumerationPtr       tree;       /* or the enumeration tree if any */
    const xmlChar        *prefix;	/* the namespace prefix if any */
    const xmlChar          *elem;	/* Element holding the attribute */
};
</pre><p>
An Attribute declaration in a DTD.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlAttributePtr"></a>xmlAttributePtr</h3><pre class="programlisting">typedef xmlAttribute *xmlAttributePtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlElementContentType"></a>enum xmlElementContentType</h3><pre class="programlisting">typedef enum {
    XML_ELEMENT_CONTENT_PCDATA = 1,
    XML_ELEMENT_CONTENT_ELEMENT,
    XML_ELEMENT_CONTENT_SEQ,
    XML_ELEMENT_CONTENT_OR
} xmlElementContentType;
</pre><p>
Possible definitions of element content types.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlElementContentOccur"></a>enum xmlElementContentOccur</h3><pre class="programlisting">typedef enum {
    XML_ELEMENT_CONTENT_ONCE = 1,
    XML_ELEMENT_CONTENT_OPT,
    XML_ELEMENT_CONTENT_MULT,
    XML_ELEMENT_CONTENT_PLUS
} xmlElementContentOccur;
</pre><p>
Possible definitions of element content occurrences.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlElementContent"></a>struct xmlElementContent</h3><pre class="programlisting">struct xmlElementContent {

    xmlElementContentType     type;	/* PCDATA, ELEMENT, SEQ or OR */
    xmlElementContentOccur    ocur;	/* ONCE, OPT, MULT or PLUS */
    const xmlChar             *name;	/* Element name */
    struct _xmlElementContent *c1;	/* first child */
    struct _xmlElementContent *c2;	/* second child */
    struct _xmlElementContent *parent;	/* parent */
    const xmlChar             *prefix;	/* Namespace prefix */
};
</pre><p>
An XML Element content as stored after parsing an element definition
in a DTD.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlElementContentPtr"></a>xmlElementContentPtr</h3><pre class="programlisting">typedef xmlElementContent *xmlElementContentPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlElementTypeVal"></a>enum xmlElementTypeVal</h3><pre class="programlisting">typedef enum {
    XML_ELEMENT_TYPE_UNDEFINED = 0,
    XML_ELEMENT_TYPE_EMPTY = 1,
    XML_ELEMENT_TYPE_ANY,
    XML_ELEMENT_TYPE_MIXED,
    XML_ELEMENT_TYPE_ELEMENT
} xmlElementTypeVal;
</pre><p>
The different possibilities for an element content type.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlElement"></a>struct xmlElement</h3><pre class="programlisting">struct xmlElement {

    void           *_private;	        /* application data */
    xmlElementType          type;       /* XML_ELEMENT_DECL, must be second ! */
    const xmlChar          *name;	/* Element name */
    struct _xmlNode    *children;	/* NULL */
    struct _xmlNode        *last;	/* NULL */
    struct _xmlDtd       *parent;	/* -&gt; DTD */
    struct _xmlNode        *next;	/* next sibling link  */
    struct _xmlNode        *prev;	/* previous sibling link  */
    struct _xmlDoc          *doc;       /* the containing document */

    xmlElementTypeVal      etype;	/* The type */
    xmlElementContentPtr content;	/* the allowed element content */
    xmlAttributePtr   attributes;	/* List of the declared attributes */
    const xmlChar        *prefix;	/* the namespace prefix if any */
#ifdef LIBXML_REGEXP_ENABLED
    xmlRegexpPtr       contModel;	/* the validating regexp */
#else
    void	      *contModel;
#endif
};
</pre><p>
An XML Element declaration from a DTD.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlElementPtr"></a>xmlElementPtr</h3><pre class="programlisting">typedef xmlElement *xmlElementPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="XML-LOCAL-NAMESPACE-CAPS"></a>XML_LOCAL_NAMESPACE</h3><pre class="programlisting">#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
</pre><p>
A namespace declaration node.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlNsType"></a>xmlNsType</h3><pre class="programlisting">typedef xmlElementType xmlNsType;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlNs"></a>struct xmlNs</h3><pre class="programlisting">struct xmlNs {

    struct _xmlNs  *next;	/* next Ns link for this node  */
    xmlNsType      type;	/* global or local */
    const xmlChar *href;	/* URL for the namespace */
    const xmlChar *prefix;	/* prefix for the namespace */
    void           *_private;   /* application data */
};
</pre><p>
An XML namespace.
Note that prefix == NULL is valid, it defines the default namespace
within the subtree (until overridden).
</p><p>
xmlNsType is unified with xmlElementType.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlNsPtr"></a>xmlNsPtr</h3><pre class="programlisting">typedef xmlNs *xmlNsPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlDtd"></a>struct xmlDtd</h3><pre class="programlisting">struct xmlDtd {

    void           *_private;	/* application data */
    xmlElementType  type;       /* XML_DTD_NODE, must be second ! */
    const xmlChar *name;	/* Name of the DTD */
    struct _xmlNode *children;	/* the value of the property link */
    struct _xmlNode *last;	/* last child link */
    struct _xmlDoc  *parent;	/* child-&gt;parent link */
    struct _xmlNode *next;	/* next sibling link  */
    struct _xmlNode *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* the containing document */

    /* End of common part */
    void          *notations;   /* Hash table for notations if any */
    void          *elements;    /* Hash table for elements if any */
    void          *attributes;  /* Hash table for attributes if any */
    void          *entities;    /* Hash table for entities if any */
    const xmlChar *ExternalID;	/* External identifier for PUBLIC DTD */
    const xmlChar *SystemID;	/* URI for a SYSTEM or PUBLIC DTD */
    void          *pentities;   /* Hash table for param entities if any */
};
</pre><p>
An XML DTD, as defined by &lt;!DOCTYPE ... There is actually one for
the internal subset and for the external subset.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlDtdPtr"></a>xmlDtdPtr</h3><pre class="programlisting">typedef xmlDtd *xmlDtdPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlAttr"></a>struct xmlAttr</h3><pre class="programlisting">struct xmlAttr {

    void           *_private;	/* application data */
    xmlElementType   type;      /* XML_ATTRIBUTE_NODE, must be second ! */
    const xmlChar   *name;      /* the name of the property */
    struct _xmlNode *children;	/* the value of the property */
    struct _xmlNode *last;	/* NULL */
    struct _xmlNode *parent;	/* child-&gt;parent link */
    struct _xmlAttr *next;	/* next sibling link  */
    struct _xmlAttr *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* the containing document */
    xmlNs           *ns;        /* pointer to the associated namespace */
    xmlAttributeType atype;     /* the attribute type if validating */
    void            *psvi;	/* for type/PSVI informations */
};
</pre><p>
An attribute on an XML node.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlAttrPtr"></a>xmlAttrPtr</h3><pre class="programlisting">typedef xmlAttr *xmlAttrPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlID"></a>struct xmlID</h3><pre class="programlisting">struct xmlID {

    struct _xmlID    *next;	/* next ID */
    const xmlChar    *value;	/* The ID name */
    xmlAttrPtr        attr;	/* The attribute holding it */
    const xmlChar    *name;	/* The attribute if attr is not available */
    int               lineno;	/* The line number if attr is not available */
};
</pre><p>
An XML ID instance.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlIDPtr"></a>xmlIDPtr</h3><pre class="programlisting">typedef xmlID *xmlIDPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlRef"></a>struct xmlRef</h3><pre class="programlisting">struct xmlRef {

    struct _xmlRef    *next;	/* next Ref */
    const xmlChar     *value;	/* The Ref name */
    xmlAttrPtr        attr;	/* The attribute holding it */
    const xmlChar    *name;	/* The attribute if attr is not available */
    int               lineno;	/* The line number if attr is not available */
};
</pre><p>
An XML IDREF instance.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlRefPtr"></a>xmlRefPtr</h3><pre class="programlisting">typedef xmlRef *xmlRefPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlBufferAllocationScheme"></a>enum xmlBufferAllocationScheme</h3><pre class="programlisting">typedef enum {
    XML_BUFFER_ALLOC_DOUBLEIT,
    XML_BUFFER_ALLOC_EXACT,
    XML_BUFFER_ALLOC_IMMUTABLE
} xmlBufferAllocationScheme;
</pre><p>
A buffer allocation scheme can be defined to either match exactly the
need or double it's allocated size each time it is found too small.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlBuffer"></a>struct xmlBuffer</h3><pre class="programlisting">struct xmlBuffer {

    xmlChar *content;		/* The buffer content UTF8 */
    unsigned int use;		/* The buffer size used */
    unsigned int size;		/* The buffer size */
    xmlBufferAllocationScheme alloc; /* The realloc method */
};
</pre><p>
A buffer structure.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlBufferPtr"></a>xmlBufferPtr</h3><pre class="programlisting">typedef xmlBuffer *xmlBufferPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlNode"></a>struct xmlNode</h3><pre class="programlisting">struct xmlNode {

    void           *_private;	/* application data */
    xmlElementType   type;	/* type number, must be second ! */
    const xmlChar   *name;      /* the name of the node, or the entity */
    struct _xmlNode *children;	/* parent-&gt;childs link */
    struct _xmlNode *last;	/* last child link */
    struct _xmlNode *parent;	/* child-&gt;parent link */
    struct _xmlNode *next;	/* next sibling link  */
    struct _xmlNode *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* the containing document */

    /* End of common part */
    xmlNs           *ns;        /* pointer to the associated namespace */
    xmlChar         *content;   /* the content */
    struct _xmlAttr *properties;/* properties list */
    xmlNs           *nsDef;     /* namespace definitions on this node */
    void            *psvi;	/* for type/PSVI informations */
    unsigned short   line;	/* line number */
    unsigned short   extra;	/* extra data for XPath/XSLT */
};
</pre><p>
A node in an XML tree.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlNodePtr"></a>xmlNodePtr</h3><pre class="programlisting">typedef xmlNode *xmlNodePtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="XML-GET-CONTENT-CAPS"></a>XML_GET_CONTENT()</h3><pre class="programlisting">#define     XML_GET_CONTENT(n)</pre><p>
Macro to extract the content pointer of a node.</p><p>

</p><div class="variablelist"><table border="0"><col align="left"><tbody><tr><td><span class="term"><i><tt>n</tt></i>:</span></td><td>


</td></tr></tbody></table></div></div><hr><div class="refsect2"><h3><a name="XML-GET-LINE-CAPS"></a>XML_GET_LINE()</h3><pre class="programlisting">#define     XML_GET_LINE(n)</pre><p>
Macro to extract the line number of an element node. 
This will work only if line numbering is activated by
calling xmlLineNumbersDefault(1) before parsing.</p><p>

</p><div class="variablelist"><table border="0"><col align="left"><tbody><tr><td><span class="term"><i><tt>n</tt></i>:</span></td><td>


</td></tr></tbody></table></div></div><hr><div class="refsect2"><h3><a name="xmlDoc"></a>struct xmlDoc</h3><pre class="programlisting">struct xmlDoc {

    void           *_private;	/* application data */
    xmlElementType  type;       /* XML_DOCUMENT_NODE, must be second ! */
    char           *name;	/* name/filename/URI of the document */
    struct _xmlNode *children;	/* the document tree */
    struct _xmlNode *last;	/* last child link */
    struct _xmlNode *parent;	/* child-&gt;parent link */
    struct _xmlNode *next;	/* next sibling link  */
    struct _xmlNode *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* autoreference to itself */

    /* End of common part */
    int             compression;/* level of zlib compression */
    int             standalone; /* standalone document (no external refs) */
    struct _xmlDtd  *intSubset;	/* the document internal subset */
    struct _xmlDtd  *extSubset;	/* the document external subset */
    struct _xmlNs   *oldNs;	/* Global namespace, the old way */
    const xmlChar  *version;	/* the XML version string */
    const xmlChar  *encoding;   /* external initial encoding, if any */
    void           *ids;        /* Hash table for ID attributes if any */
    void           *refs;       /* Hash table for IDREFs attributes if any */
    const xmlChar  *URL;	/* The URI for that document */
    int             charset;    /* encoding of the in-memory content
				   actually an xmlCharEncoding */
    struct _xmlDict *dict;      /* dict used to allocate names or NULL */
    void           *psvi;	/* for type/PSVI informations */
};
</pre><p>
An XML document.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlDocPtr"></a>xmlDocPtr</h3><pre class="programlisting">typedef xmlDoc *xmlDocPtr;
</pre><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlChildrenNode"></a>xmlChildrenNode</h3><pre class="programlisting">#define xmlChildrenNode children
</pre><p>
Macro for compatibility naming layer with libxml1.</p><p>

</p></div><hr><div class="refsect2"><h3><a name="xmlRootNode"></a>xmlRootNode</h3><pre class="programlisting">#define xmlRootNode children
</pre><p>
Macro for compatibility naming layer with libxml1.</p><p>

</p></div></div></div><table class="navigation" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle"><td align="left"><a accesskey="p" href="libxml-catalog.html"><b>&lt;&lt; catalog</b></a></td><td align="right"><a accesskey="n" href="libxml-globals.html"><b>globals &gt;&gt;</b></a></td></tr></table></body></html>
