<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="SHORTCUT ICON" href="/favicon.ico">
<style type="text/css"><!--
TD {font-family: Verdana,Arial,Helvetica}
BODY {font-family: Verdana,Arial,Helvetica; margin-top: 2em; margin-left: 0em; margin-right: 0em}
H1 {font-family: Verdana,Arial,Helvetica}
H2 {font-family: Verdana,Arial,Helvetica}
H3 {font-family: Verdana,Arial,Helvetica}
A:link, A:visited, A:active { text-decoration: underline }
--></style>
<title>Python and bindings</title>
</head>
<body bgcolor="#8b7765" text="#000000" link="#000000" vlink="#000000">
<table border="0" width="100%" cellpadding="5" cellspacing="0" align="center"><tr>
<td width="180">
<a href="http://www.gnome.org/"><img src="gnome2.png" alt="Gnome2 Logo"></a><a href="http://www.w3.org/Status"><img src="w3c.png" alt="W3C Logo"></a><a href="http://www.redhat.com/"><img src="redhat.gif" alt="Red Hat Logo"></a><div align="left"><a href="http://xmlsoft.org/"><img src="Libxml2-Logo-180x168.gif" alt="Made with Libxml2 Logo"></a></div>
</td>
<td><table border="0" width="90%" cellpadding="2" cellspacing="0" align="center" bgcolor="#000000"><tr><td><table width="100%" border="0" cellspacing="1" cellpadding="3" bgcolor="#fffacd"><tr><td align="center">
<h1>The XML C library for Gnome</h1>
<h2>Python and bindings</h2>
</td></tr></table></td></tr></table></td>
</tr></table>
<table border="0" cellpadding="4" cellspacing="0" width="100%" align="center"><tr><td bgcolor="#8b7765"><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr>
<td valign="top" width="200" bgcolor="#8b7765"><table border="0" cellspacing="0" cellpadding="1" width="100%" bgcolor="#000000"><tr><td>
<table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr><td colspan="1" bgcolor="#eecfa1" align="center"><center><b>Main Menu</b></center></td></tr>
<tr><td bgcolor="#fffacd"><ul>
<li><a href="index.html">Home</a></li>
<li><a href="intro.html">Introduction</a></li>
<li><a href="FAQ.html">FAQ</a></li>
<li><a href="docs.html">Documentation</a></li>
<li><a href="bugs.html">Reporting bugs and getting help</a></li>
<li><a href="help.html">How to help</a></li>
<li><a href="downloads.html">Downloads</a></li>
<li><a href="news.html">News</a></li>
<li><a href="XMLinfo.html">XML</a></li>
<li><a href="XSLT.html">XSLT</a></li>
<li><a href="python.html">Python and bindings</a></li>
<li><a href="architecture.html">libxml architecture</a></li>
<li><a href="tree.html">The tree output</a></li>
<li><a href="interface.html">The SAX interface</a></li>
<li><a href="xmldtd.html">Validation &amp; DTDs</a></li>
<li><a href="xmlmem.html">Memory Management</a></li>
<li><a href="encoding.html">Encodings support</a></li>
<li><a href="xmlio.html">I/O Interfaces</a></li>
<li><a href="catalog.html">Catalog support</a></li>
<li><a href="library.html">The parser interfaces</a></li>
<li><a href="entities.html">Entities or no entities</a></li>
<li><a href="namespaces.html">Namespaces</a></li>
<li><a href="upgrade.html">Upgrading 1.x code</a></li>
<li><a href="threads.html">Thread safety</a></li>
<li><a href="DOM.html">DOM Principles</a></li>
<li><a href="example.html">A real example</a></li>
<li><a href="contribs.html">Contributions</a></li>
<li><a href="tutorial/index.html">Tutorial</a></li>
<li>
<a href="xml.html">flat page</a>, <a href="site.xsl">stylesheet</a>
</li>
</ul></td></tr>
</table>
<table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr><td colspan="1" bgcolor="#eecfa1" align="center"><center><b>API Indexes</b></center></td></tr>
<tr><td bgcolor="#fffacd"><ul>
<li><a href="APIchunk0.html">Alphabetic</a></li>
<li><a href="APIconstructors.html">Constructors</a></li>
<li><a href="APIfunctions.html">Functions/Types</a></li>
<li><a href="APIfiles.html">Modules</a></li>
<li><a href="APIsymbols.html">Symbols</a></li>
</ul></td></tr>
</table>
<table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr><td colspan="1" bgcolor="#eecfa1" align="center"><center><b>Related links</b></center></td></tr>
<tr><td bgcolor="#fffacd"><ul>
<li><a href="http://mail.gnome.org/archives/xml/">Mail archive</a></li>
<li><a href="http://xmlsoft.org/XSLT/">XSLT libxslt</a></li>
<li><a href="http://phd.cs.unibo.it/gdome2/">DOM gdome2</a></li>
<li><a href="http://www.aleksey.com/xmlsec/">XML-DSig xmlsec</a></li>
<li><a href="ftp://xmlsoft.org/">FTP</a></li>
<li><a href="http://www.fh-frankfurt.de/~igor/projects/libxml/">Windows binaries</a></li>
<li><a href="http://garypennington.net/libxml2/">Solaris binaries</a></li>
<li><a href="http://www.zveno.com/open_source/libxml2xslt.html">MacOsX binaries</a></li>
<li><a href="http://sourceforge.net/projects/libxml2-pas/">Pascal bindings</a></li>
<li><a href="http://bugzilla.gnome.org/buglist.cgi?product=libxml&amp;product=libxml2">Bug Tracker</a></li>
</ul></td></tr>
</table>
</td></tr></table></td>
<td valign="top" bgcolor="#8b7765"><table border="0" cellspacing="0" cellpadding="1" width="100%"><tr><td><table border="0" cellspacing="0" cellpadding="1" width="100%" bgcolor="#000000"><tr><td><table border="0" cellpadding="3" cellspacing="1" width="100%"><tr><td bgcolor="#fffacd">
<p>There are a number of language bindings and wrappers available for
libxml2, the list below is not exhaustive. Please contact the <a href="http://mail.gnome.org/mailman/listinfo/xml-bindings">xml-bindings@gnome.org</a>
(<a href="http://mail.gnome.org/archives/xml-bindings/">archives</a>) in
order to get updates to this list or to discuss the specific topic of libxml2
or libxslt wrappers or bindings:</p>
<ul>
<li>
<a href="mailto:ari@lusis.org">Ari Johnson</a> provides a  C++ wrapper
    for libxml:<br>
    Website: <a href="http://lusis.org/~ari/xml%2B%2B/">http://lusis.org/~ari/xml++/</a><br>
    Download: <a href="http://lusis.org/~ari/xml%2B%2B/libxml%2B%2B.tar.gz">http://lusis.org/~ari/xml++/libxml++.tar.gz</a>
</li>
  <li>There is another <a href="http://libgdome-cpp.berlios.de/">C++ wrapper
    based on the gdome2 bindings</a> maintained by Tobias Peters.</li>
  <li>and a third C++ wrapper by Peter Jones &lt;pjones@pmade.org&gt;
    <p>Website: <a href="http://pmade.org/pjones/software/xmlwrapp/">http://pmade.org/pjones/software/xmlwrapp/</a>
</p>
  </li>
  <li>
<a href="http://mail.gnome.org/archives/xml/2001-March/msg00014.html">Matt
    Sergeant</a> developed <a href="http://axkit.org/download/">XML::LibXSLT</a>, a Perl wrapper for
    libxml2/libxslt as part of the <a href="http://axkit.com/">AxKit XML
    application server</a>.</li>
  <li>
<a href="mailto:dkuhlman@cutter.rexx.com">Dave Kuhlman</a> provides an
    earlier version of the libxml/libxslt <a href="http://www.rexx.com/~dkuhlman">wrappers for Python</a>.</li>
  <li>Gopal.V and Peter Minten develop <a href="http://savannah.gnu.org/projects/libxmlsharp">libxml#</a>, a set of
    C# libxml2 bindings.</li>
  <li>Petr Kozelka provides <a href="http://sourceforge.net/projects/libxml2-pas">Pascal units to glue
    libxml2</a> with Kylix, Delphi and other Pascal compilers.</li>
  <li>Uwe Fechner also provides <a href="http://sourceforge.net/projects/idom2-pas/">idom2</a>, a DOM2
    implementation for Kylix2/D5/D6 from Borland.</li>
  <li>Wai-Sun &quot;Squidster&quot; Chia provides <a href="http://www.rubycolor.org/arc/redist/">bindings for Ruby</a>  and
    libxml2 bindings are also available in Ruby through the <a href="http://libgdome-ruby.berlios.de/">libgdome-ruby</a> module
    maintained by Tobias Peters.</li>
  <li>Steve Ball and contributors maintains <a href="http://tclxml.sourceforge.net/">libxml2 and libxslt bindings for
    Tcl</a>.</li>
  <li>There is support for libxml2 in the DOM module of PHP.</li>
</ul>
<p>The distribution includes a set of Python bindings, which are guaranteed
to be maintained as part of the library in the future, though the Python
interface have not yet reached the maturity of the C API.</p>
<p>To install the Python bindings there are 2 options:</p>
<ul>
<li>If you use an RPM based distribution, simply install the <a href="http://rpmfind.net/linux/rpm2html/search.php?query=libxml2-python">libxml2-python
    RPM</a> (and if needed the <a href="http://rpmfind.net/linux/rpm2html/search.php?query=libxslt-python">libxslt-python
    RPM</a>).</li>
  <li>Otherwise use the <a href="ftp://xmlsoft.org/python/">libxml2-python
    module distribution</a> corresponding to your installed version of
    libxml2 and libxslt. Note that to install it you will need both libxml2
    and libxslt installed and run &quot;python setup.py build install&quot; in the
    module tree.</li>
</ul>
<p>The distribution includes a set of examples and regression tests for the
python bindings in the <code>python/tests</code> directory. Here are some
excerpts from those tests:</p>
<h3>tst.py:</h3>
<p>This is a basic test of the file interface and DOM navigation:</p>
<pre>import libxml2

doc = libxml2.parseFile(&quot;tst.xml&quot;)
if doc.name != &quot;tst.xml&quot;:
    print &quot;doc.name failed&quot;
    sys.exit(1)
root = doc.children
if root.name != &quot;doc&quot;:
    print &quot;root.name failed&quot;
    sys.exit(1)
child = root.children
if child.name != &quot;foo&quot;:
    print &quot;child.name failed&quot;
    sys.exit(1)
doc.freeDoc()</pre>
<p>The Python module is called libxml2; parseFile is the equivalent of
xmlParseFile (most of the bindings are automatically generated, and the xml
prefix is removed and the casing convention are kept). All node seen at the
binding level share the same subset of accessors:</p>
<ul>
<li>
<code>name</code> : returns the node name</li>
  <li>
<code>type</code> : returns a string indicating the node type</li>
  <li>
<code>content</code> : returns the content of the node, it is based on
    xmlNodeGetContent() and hence is recursive.</li>
  <li>
<code>parent</code> , <code>children</code>, <code>last</code>,
    <code>next</code>, <code>prev</code>, <code>doc</code>,
    <code>properties</code>: pointing to the associated element in the tree,
    those may return None in case no such link exists.</li>
</ul>
<p>Also note the need to explicitly deallocate documents with freeDoc() .
Reference counting for libxml2 trees would need quite a lot of work to
function properly, and rather than risk memory leaks if not implemented
correctly it sounds safer to have an explicit function to free a tree. The
wrapper python objects like doc, root or child are them automatically garbage
collected.</p>
<h3>validate.py:</h3>
<p>This test check the validation interfaces and redirection of error
messages:</p>
<pre>import libxml2

#deactivate error messages from the validation
def noerr(ctx, str):
    pass

libxml2.registerErrorHandler(noerr, None)

ctxt = libxml2.createFileParserCtxt(&quot;invalid.xml&quot;)
ctxt.validate(1)
ctxt.parseDocument()
doc = ctxt.doc()
valid = ctxt.isValid()
doc.freeDoc()
if valid != 0:
    print &quot;validity check failed&quot;</pre>
<p>The first thing to notice is the call to registerErrorHandler(), it
defines a new error handler global to the library. It is used to avoid seeing
the error messages when trying to validate the invalid document.</p>
<p>The main interest of that test is the creation of a parser context with
createFileParserCtxt() and how the behaviour can be changed before calling
parseDocument() . Similarly the informations resulting from the parsing phase
are also available using context methods.</p>
<p>Contexts like nodes are defined as class and the libxml2 wrappers maps the
C function interfaces in terms of objects method as much as possible. The
best to get a complete view of what methods are supported is to look at the
libxml2.py module containing all the wrappers.</p>
<h3>push.py:</h3>
<p>This test show how to activate the push parser interface:</p>
<pre>import libxml2

ctxt = libxml2.createPushParser(None, &quot;&lt;foo&quot;, 4, &quot;test.xml&quot;)
ctxt.parseChunk(&quot;/&gt;&quot;, 2, 1)
doc = ctxt.doc()

doc.freeDoc()</pre>
<p>The context is created with a special call based on the
xmlCreatePushParser() from the C library. The first argument is an optional
SAX callback object, then the initial set of data, the length and the name of
the resource in case URI-References need to be computed by the parser.</p>
<p>Then the data are pushed using the parseChunk() method, the last call
setting the third argument terminate to 1.</p>
<h3>pushSAX.py:</h3>
<p>this test show the use of the event based parsing interfaces. In this case
the parser does not build a document, but provides callback information as
the parser makes progresses analyzing the data being provided:</p>
<pre>import libxml2
log = &quot;&quot;

class callback:
    def startDocument(self):
        global log
        log = log + &quot;startDocument:&quot;

    def endDocument(self):
        global log
        log = log + &quot;endDocument:&quot;

    def startElement(self, tag, attrs):
        global log
        log = log + &quot;startElement %s %s:&quot; % (tag, attrs)

    def endElement(self, tag):
        global log
        log = log + &quot;endElement %s:&quot; % (tag)

    def characters(self, data):
        global log
        log = log + &quot;characters: %s:&quot; % (data)

    def warning(self, msg):
        global log
        log = log + &quot;warning: %s:&quot; % (msg)

    def error(self, msg):
        global log
        log = log + &quot;error: %s:&quot; % (msg)

    def fatalError(self, msg):
        global log
        log = log + &quot;fatalError: %s:&quot; % (msg)

handler = callback()

ctxt = libxml2.createPushParser(handler, &quot;&lt;foo&quot;, 4, &quot;test.xml&quot;)
chunk = &quot; url='tst'&gt;b&quot;
ctxt.parseChunk(chunk, len(chunk), 0)
chunk = &quot;ar&lt;/foo&gt;&quot;
ctxt.parseChunk(chunk, len(chunk), 1)

reference = &quot;startDocument:startElement foo {'url': 'tst'}:&quot; + \ 
            &quot;characters: bar:endElement foo:endDocument:&quot;
if log != reference:
    print &quot;Error got: %s&quot; % log
    print &quot;Expected: %s&quot; % reference</pre>
<p>The key object in that test is the handler, it provides a number of entry
points which can be called by the parser as it makes progresses to indicate
the information set obtained. The full set of callback is larger than what
the callback class in that specific example implements (see the SAX
definition for a complete list). The wrapper will only call those supplied by
the object when activated. The startElement receives the names of the element
and a dictionary containing the attributes carried by this element.</p>
<p>Also note that the reference string generated from the callback shows a
single character call even though the string &quot;bar&quot; is passed to the parser
from 2 different call to parseChunk()</p>
<h3>xpath.py:</h3>
<p>This is a basic test of XPath wrappers support</p>
<pre>import libxml2

doc = libxml2.parseFile(&quot;tst.xml&quot;)
ctxt = doc.xpathNewContext()
res = ctxt.xpathEval(&quot;//*&quot;)
if len(res) != 2:
    print &quot;xpath query: wrong node set size&quot;
    sys.exit(1)
if res[0].name != &quot;doc&quot; or res[1].name != &quot;foo&quot;:
    print &quot;xpath query: wrong node set value&quot;
    sys.exit(1)
doc.freeDoc()
ctxt.xpathFreeContext()</pre>
<p>This test parses a file, then create an XPath context to evaluate XPath
expression on it. The xpathEval() method execute an XPath query and returns
the result mapped in a Python way. String and numbers are natively converted,
and node sets are returned as a tuple of libxml2 Python nodes wrappers. Like
the document, the XPath context need to be freed explicitly, also not that
the result of the XPath query may point back to the document tree and hence
the document must be freed after the result of the query is used.</p>
<h3>xpathext.py:</h3>
<p>This test shows how to extend the XPath engine with functions written in
python:</p>
<pre>import libxml2

def foo(ctx, x):
    return x + 1

doc = libxml2.parseFile(&quot;tst.xml&quot;)
ctxt = doc.xpathNewContext()
libxml2.registerXPathFunction(ctxt._o, &quot;foo&quot;, None, foo)
res = ctxt.xpathEval(&quot;foo(1)&quot;)
if res != 2:
    print &quot;xpath extension failure&quot;
doc.freeDoc()
ctxt.xpathFreeContext()</pre>
<p>Note how the extension function is registered with the context (but that
part is not yet finalized, this may change slightly in the future).</p>
<h3>tstxpath.py:</h3>
<p>This test is similar to the previous one but shows how the extension
function can access the XPath evaluation context:</p>
<pre>def foo(ctx, x):
    global called

    #
    # test that access to the XPath evaluation contexts
    #
    pctxt = libxml2.xpathParserContext(_obj=ctx)
    ctxt = pctxt.context()
    called = ctxt.function()
    return x + 1</pre>
<p>All the interfaces around the XPath parser(or rather evaluation) context
are not finalized, but it should be sufficient to do contextual work at the
evaluation point.</p>
<h3>Memory debugging:</h3>
<p>last but not least, all tests starts with the following prologue:</p>
<pre>#memory debug specific
libxml2.debugMemory(1)</pre>
<p>and ends with the following epilogue:</p>
<pre>#memory debug specific
libxml2.cleanupParser()
if libxml2.debugMemory(1) == 0:
    print &quot;OK&quot;
else:
    print &quot;Memory leak %d bytes&quot; % (libxml2.debugMemory(1))
    libxml2.dumpMemory()</pre>
<p>Those activate the memory debugging interface of libxml2 where all
allocated block in the library are tracked. The prologue then cleans up the
library state and checks that all allocated memory has been freed. If not it
calls dumpMemory() which saves that list in a <code>.memdump</code> file.</p>
<p><a href="bugs.html">Daniel Veillard</a></p>
</td></tr></table></td></tr></table></td></tr></table></td>
</tr></table></td></tr></table>
</body>
</html>
