#!/usr/bin/python -u
#
# generate a tester program for the API
#
import sys
import string
try:
    import libxml2
except:
    print "libxml2 python bindings not available, skipping testapi.c generation"
    sys.exit(0)

#
# Modules we don't want skip in API test
#
skipped_modules = [ "SAX", "SAX2", "xlink", "threads", "globals",
  "xpathInternals", "xmlunicode", "parserInternals", "xmlmemory",
  "xmlversion", "debugXML", "xmlexports", "DOCBparser",

  # temporary
  "xmlautomata", "xmlregexp", "c14n",
  
]

#
# Some function really need to be skipped for the tests.
#
skipped_functions = [
# block on I/O
"xmlFdRead", "xmlReadFd", "xmlCtxtReadFd",
"htmlFdRead", "htmlReadFd", "htmlCtxtReadFd",
"xmlReaderNewFd", 
"xmlIORead", "xmlReadIO", "xmlCtxtReadIO",
"htmlIORead", "htmlReadIO", "htmlCtxtReadIO",
"xmlReaderNewIO", 
# library state cleanup, generate false leak informations and other
# troubles, heavillyb tested otherwise.
"xmlCleanupParser", "xmlRelaxNGCleanupTypes",
# hard to avoid leaks in the tests
"xmlStrcat", "xmlStrncat", "xmlCatalogAddLocal",
# unimplemented
"xmlTextReaderReadInnerXml", "xmlTextReaderReadOuterXml",
"xmlTextReaderReadString",
# destructor
"xmlListDelete", "xmlOutputBufferClose",
# deprecated
"xmlCatalogGetPublic", "xmlCatalogGetSystem", "xmlEncodeEntities",
# allocators
"xmlMemFree",
]

#
# Those functions have side effect on the global state
# and hence generate errors on memory allocation tests
#
skipped_memcheck = [ "xmlLoadCatalog", "xmlAddEncodingAlias",
   "xmlSchemaInitTypes", "xmlNanoFTPProxy", "xmlNanoFTPScanProxy",
   "xmlNanoHTTPScanProxy", "xmlResetLastError", "xmlCatalogConvert",
   "xmlCatalogRemove", "xmlLoadCatalogs", "xmlCleanupCharEncodingHandlers",
   "xmlInitCharEncodingHandlers", "xmlCatalogCleanup",
   "htmlParseFile" # loads the catalogs
]

#
# Extra code needed for some test cases
#
extra_post_call = {
   "xmlAddChild": 
       "if (ret_val == NULL) { xmlFreeNode(cur) ; cur = NULL ; }",
   "xmlAddChildList": 
       "if (ret_val == NULL) { xmlFreeNodeList(cur) ; cur = NULL ; }",
   "xmlAddSibling":
       "if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }",
   "xmlAddNextSibling":
       "if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }",
   "xmlAddPrevSibling": 
       "if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }",
   "xmlDocSetRootElement": 
       "if (doc == NULL) { xmlFreeNode(root) ; root = NULL ; }",
   "xmlReplaceNode": 
       """if ((old == NULL) || (old->parent == NULL)) {
              xmlFreeNode(cur) ; cur = NULL ; }""",
   "xmlTextMerge": 
       """if ((first != NULL) && (first->type != XML_TEXT_NODE)) {
              xmlFreeNode(second) ; second = NULL ; }""",
   "xmlBuildQName": 
       """if ((ret_val != NULL) && (ret_val != ncname) &&
              (ret_val != prefix) && (ret_val != memory))
              xmlFree(ret_val);
	  ret_val = NULL;""",
   # Functions which deallocates one of their parameters
   "xmlXPathConvertBoolean": """val = NULL;""",
   "xmlXPathConvertNumber": """val = NULL;""",
   "xmlXPathConvertString": """val = NULL;""",
   "xmlSaveFileTo": """buf = NULL;""",
   "xmlSaveFormatFileTo": """buf = NULL;"""
}

modules = []

def is_skipped_module(name):
    for mod in skipped_modules:
        if mod == name:
	    return 1
    return 0

def is_skipped_function(name):
    for fun in skipped_functions:
        if fun == name:
	    return 1
    # Do not test destructors
    if string.find(name, 'Free') != -1:
        return 1
    return 0

def is_skipped_memcheck(name):
    for fun in skipped_memcheck:
        if fun == name:
	    return 1
    return 0

missing_types = {}
def add_missing_type(name, func):
    try:
        list = missing_types[name]
	list.append(func)
    except:
        missing_types[name] = [func]

#
# Open the input API description and the C test program result
#
doc = libxml2.readFile('doc/libxml2-api.xml', None, 0)
if doc == None:
    print "Failed to load doc/libxml2-api.xml"
    sys.exit(1)
test = open('testapi.c', 'w')
ctxt = doc.xpathNewContext()
headers = ctxt.xpathEval("/api/files/file")

#
# Generate the test header
#
test.write("""/*
 * testapi.c: libxml2 API tester program.
 *
 * Automatically generated by gentest.py from libxml2-api.xml
 *
 * See Copyright for the status of this software.
 *
 * daniel@veillard.com
 */

#include <stdio.h>
#include <libxml/xmlerror.h>
#include <libxml/relaxng.h>

static int testlibxml2(void);

static int generic_errors = 0;
static int call_tests = 0;
static int function_tests = 0;

static xmlChar chartab[1024] = "  chartab\\n";

static void
structured_errors(void *userData ATTRIBUTE_UNUSED,
                  xmlErrorPtr error ATTRIBUTE_UNUSED) {
    generic_errors++;
}

int main(void) {
    int ret;
    int blocks, mem;

    xmlInitParser();
#ifdef LIBXML_SCHEMAS_ENABLED
    xmlRelaxNGInitTypes();
#endif

    LIBXML_TEST_VERSION

    xmlSetStructuredErrorFunc(NULL, structured_errors);

    ret = testlibxml2();

    xmlCleanupParser();
    blocks = xmlMemBlocks();
    mem = xmlMemUsed();
    if ((blocks != 0) || (mem != 0)) {
        printf("testapi leaked %d bytes in %d blocks\\n", mem, blocks);
    }
    xmlMemoryDump();

    return (ret != 0);
}

""");

#
# Load the interfaces
# 
for file in headers:
    name = file.xpathEval('string(@name)')
    if (name == None) or (name == ''):
        continue

    #
    # Some module may be skipped because they don't really consists
    # of user callable APIs
    #
    if is_skipped_module(name):
        continue

    #
    # do not test deprecated APIs
    #
    desc = file.xpathEval('string(description)')
    if string.find(desc, 'DEPRECATED') != -1:
        print "Skipping deprecated interface %s" % name
	continue;

    test.write("#include <libxml/%s.h>\n" % name)
    modules.append(name)
        
#
# Generate the callers signatures
# 
for module in modules:
    test.write("static int test_%s(void);\n" % module);

#
# Provide the type generators and destructors for the parameters
#

def type_convert(str, name, info, module, function, pos):
    res = string.replace(str, " *", "_ptr")
    res = string.replace(res, " ", "_")
    res = string.replace(res, "htmlNode", "xmlNode")
    res = string.replace(res, "htmlDoc", "xmlDoc")
    res = string.replace(res, "htmlParser", "xmlParser")
    if res == 'const_char_ptr':
        if string.find(name, "file") != -1 or \
           string.find(name, "uri") != -1 or \
           string.find(name, "URI") != -1 or \
           string.find(info, "filename") != -1 or \
           string.find(info, "URI") != -1 or \
           string.find(info, "URL") != -1:
	    if string.find(function, "Save") != -1:
	        return('fileoutput')
	    return('filepath')
    if res == 'void_ptr':
        if module == 'nanoftp' and name == 'ctx':
	    return('xmlNanoFTPCtxtPtr')
        if function == 'xmlNanoFTPNewCtxt':
	    return('xmlNanoFTPCtxtPtr')
        if module == 'nanohttp' and name == 'ctx':
	    return('xmlNanoHTTPCtxtPtr')
        if function == 'xmlIOHTTPOpenW':
	    return('xmlNanoHTTPCtxtPtr')
	if string.find(name, "data") != -1:
	    return('userdata');
	if string.find(name, "user") != -1:
	    return('userdata');
    if res == 'xmlDoc_ptr':
        res = 'xmlDocPtr';
    if res == 'xmlNode_ptr':
        res = 'xmlNodePtr';
    if res == 'xmlDict_ptr':
        res = 'xmlDictPtr';
    if res == 'xmlNodePtr' and pos != 0:
        if (function == 'xmlAddChild' and pos == 2) or \
	   (function == 'xmlAddChildList' and pos == 2) or \
           (function == 'xmlAddNextSibling' and pos == 2) or \
           (function == 'xmlAddSibling' and pos == 2) or \
           (function == 'xmlDocSetRootElement' and pos == 2) or \
           (function == 'xmlReplaceNode' and pos == 2) or \
           (function == 'xmlTextMerge') or \
	   (function == 'xmlAddPrevSibling' and pos == 2):
	    return('xmlNodePtr_in');
        
    return res

known_param_types = [ "int", "const_char_ptr", "const_xmlChar_ptr",
   "xmlParserCtxtPtr", "xmlDocPtr", "filepath", "fileoutput",
   "xmlNodePtr", "xmlNodePtr_in", "userdata", "xmlChar_ptr",
   "xmlTextWriterPtr", "xmlTextReaderPtr", "xmlBufferPtr",
   "xmlListPtr", "xmlXPathObjectPtr", "xmlHashTablePtr", "xmlValidCtxtPtr",
   "void_ptr", "xmlOutputBufferPtr", "xmlCharEncoding",
   "unsigned_int"
]

def is_known_param_type(name):
    for type in known_param_types:
        if type == name:
	    return 1
    return 0

test.write("""
#define gen_nb_void_ptr 1

static void *gen_void_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_void_ptr(int no ATTRIBUTE_UNUSED, void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_userdata 3

static void *gen_userdata(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((void *) &call_tests);
    if (no == 1) return((void *) -1);
    return(NULL);
}
static void des_userdata(int no ATTRIBUTE_UNUSED, void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}


#define gen_nb_int 4

static int gen_int(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 1) return(-1);
    if (no == 2) return(122);
    return(-1);
}

static void des_int(int no ATTRIBUTE_UNUSED, int val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_unsigned_int 3

static unsigned int gen_unsigned_int(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(122);
    return(-1);
}

static void des_unsigned_int(int no ATTRIBUTE_UNUSED, unsigned int val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_const_char_ptr 4

static const char *gen_const_char_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return("foo");
    if (no == 1) return("<foo/>");
    if (no == 2) return("test/ent2");
    return(NULL);
}
static void des_const_char_ptr(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlChar_ptr 2

static xmlChar *gen_xmlChar_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(&chartab[0]);
    return(NULL);
}
static void des_xmlChar_ptr(int no ATTRIBUTE_UNUSED, xmlChar *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_const_xmlChar_ptr 5

static const xmlChar *gen_const_xmlChar_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((const xmlChar *) "foo");
    if (no == 1) return((const xmlChar *) "<foo/>");
    if (no == 2) return((const xmlChar *) "nøne");
    if (no == 3) return((const xmlChar *) " 2ab ");
    return(NULL);
}
static void des_const_xmlChar_ptr(int no ATTRIBUTE_UNUSED, const xmlChar *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_filepath 8

static const char *gen_filepath(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return("missing.xml");
    if (no == 1) return("<foo/>");
    if (no == 2) return("test/ent2");
    if (no == 3) return("test/valid/REC-xml-19980210.xml");
    if (no == 4) return("test/valid/xhtml1-strict.dtd");
    if (no == 5) return("http://missing.example.org/");
    if (no == 6) return("http://missing. example.org/");
    return(NULL);
}
static void des_filepath(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_fileoutput 6

static const char *gen_fileoutput(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return("/missing.xml");
    if (no == 1) return("<foo/>");
    if (no == 2) return("ftp://missing.example.org/foo");
    if (no == 3) return("http://missing.example.org/");
    if (no == 4) return("http://missing. example.org/");
    return(NULL);
}
static void des_fileoutput(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlParserCtxtPtr 2
static xmlParserCtxtPtr gen_xmlParserCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewParserCtxt());
    return(NULL);
}
static void des_xmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, xmlParserCtxtPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL)
        xmlFreeParserCtxt(val);
}

#define gen_nb_xmlValidCtxtPtr 2
static xmlValidCtxtPtr gen_xmlValidCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewValidCtxt());
    return(NULL);
}
static void des_xmlValidCtxtPtr(int no ATTRIBUTE_UNUSED, xmlValidCtxtPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL)
        xmlFreeValidCtxt(val);
}

#define gen_nb_xmlDocPtr 3
static xmlDocPtr gen_xmlDocPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewDoc(BAD_CAST "1.0"));
    if (no == 1) return(xmlReadMemory("<foo/>", 6, "test", NULL, 0));
    return(NULL);
}
static void des_xmlDocPtr(int no ATTRIBUTE_UNUSED, xmlDocPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL)
        xmlFreeDoc(val);
}

#define gen_nb_xmlNodePtr 2
static xmlNodePtr gen_xmlNodePtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewPI(BAD_CAST "test", NULL));
    return(NULL);
}
static void des_xmlNodePtr(int no ATTRIBUTE_UNUSED, xmlNodePtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlUnlinkNode(val);
        xmlFreeNode(val);
    }
}

#define gen_nb_xmlNodePtr_in 3
static xmlNodePtr gen_xmlNodePtr_in(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewPI(BAD_CAST "test", NULL));
    if (no == 0) return(xmlNewText(BAD_CAST "text"));
    return(NULL);
}
static void des_xmlNodePtr_in(int no ATTRIBUTE_UNUSED, xmlNodePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlTextWriterPtr 2
static xmlTextWriterPtr gen_xmlTextWriterPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewTextWriterFilename("test.out", 0));
    return(NULL);
}
static void des_xmlTextWriterPtr(int no ATTRIBUTE_UNUSED, xmlTextWriterPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) xmlFreeTextWriter(val);
}

#define gen_nb_xmlTextReaderPtr 4
static xmlTextReaderPtr gen_xmlTextReaderPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewTextReaderFilename("test/ent2"));
    if (no == 1) return(xmlNewTextReaderFilename("test/valid/REC-xml-19980210.xml"));
    if (no == 2) return(xmlNewTextReaderFilename("test/valid/dtds/xhtml1-strict.dtd"));
    return(NULL);
}
static void des_xmlTextReaderPtr(int no ATTRIBUTE_UNUSED, xmlTextReaderPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) xmlFreeTextReader(val);
}

#define gen_nb_xmlBufferPtr 2
static xmlBufferPtr gen_xmlBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlBufferCreate());
    return(NULL);
}
static void des_xmlBufferPtr(int no ATTRIBUTE_UNUSED, xmlBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlBufferFree(val);
    }
}

#define gen_nb_xmlListPtr 2
static xmlListPtr gen_xmlListPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlListCreate(NULL, NULL));
    return(NULL);
}
static void des_xmlListPtr(int no ATTRIBUTE_UNUSED, xmlListPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlListDelete(val);
    }
}

#define gen_nb_xmlHashTablePtr 2
static xmlHashTablePtr gen_xmlHashTablePtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlHashCreate(10));
    return(NULL);
}
static void des_xmlHashTablePtr(int no ATTRIBUTE_UNUSED, xmlHashTablePtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlHashFree(val, NULL);
    }
}

#include <libxml/xpathInternals.h>

#define gen_nb_xmlXPathObjectPtr 5
static xmlXPathObjectPtr gen_xmlXPathObjectPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlXPathNewString(BAD_CAST "string object"));
    if (no == 1) return(xmlXPathNewFloat(1.1));
    if (no == 2) return(xmlXPathNewBoolean(1));
    if (no == 3) return(xmlXPathNewNodeSet(NULL));
    return(NULL);
}
static void des_xmlXPathObjectPtr(int no ATTRIBUTE_UNUSED, xmlXPathObjectPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlXPathFreeObject(val);
    }
}

#define gen_nb_xmlOutputBufferPtr 2
static xmlOutputBufferPtr gen_xmlOutputBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlOutputBufferCreateFilename("test.out", NULL, 0));
    return(NULL);
}
static void des_xmlOutputBufferPtr(int no ATTRIBUTE_UNUSED, xmlOutputBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlOutputBufferClose(val);
    }
}

#define gen_nb_xmlCharEncoding 4
static xmlCharEncoding gen_xmlCharEncoding(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(XML_CHAR_ENCODING_UTF8);
    if (no == 1) return(XML_CHAR_ENCODING_NONE);
    if (no == 0) return(XML_CHAR_ENCODING_8859_1);
    return(XML_CHAR_ENCODING_ERROR);
}
static void des_xmlCharEncoding(int no ATTRIBUTE_UNUSED, xmlCharEncoding val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

""");

#
# Provide the type destructors for the return values
#

known_return_types = [ "int", "const_char_ptr", "xmlDocPtr", "xmlNodePtr",
                       "xmlChar_ptr", "const_xmlChar_ptr", "void_ptr",
		       "xmlXPathObjectPtr", "xmlCharEncoding" ];

def is_known_return_type(name):
    for type in known_return_types:
        if type == name:
	    return 1
    return 0

test.write("""
static void desret_int(int val ATTRIBUTE_UNUSED) {
}
static void desret_xmlCharEncoding(xmlCharEncoding val ATTRIBUTE_UNUSED) {
}
static void desret_void_ptr(void *val ATTRIBUTE_UNUSED) {
}
static void desret_const_char_ptr(const char *val ATTRIBUTE_UNUSED) {
}
static void desret_const_xmlChar_ptr(const xmlChar *val ATTRIBUTE_UNUSED) {
}
static void desret_xmlChar_ptr(xmlChar *val) {
    if (val != NULL)
	xmlFree(val);
}
static void desret_xmlDocPtr(xmlDocPtr val) {
    xmlFreeDoc(val);
}
static void desret_xmlNodePtr(xmlNodePtr val) {
    xmlUnlinkNode(val);
    xmlFreeNode(val);
}
static void desret_xmlXPathObjectPtr(xmlXPathObjectPtr val) {
    if (val != NULL) {
        xmlXPathFreeObject(val);
    }
}
""");

#
# Generate the top caller
# 

test.write("""
/**
 * testlibxml2:
 *
 * Main entry point of the tester for the full libxml2 module,
 * it calls all the tester entry point for each module.
 *
 * Returns the number of error found
 */
static int
testlibxml2(void)
{
    int ret = 0;

""")

for module in modules:
    test.write("    ret += test_%s();\n" % module)

test.write("""
    printf("Total: %d functions, %d tests, %d errors\\n",
           function_tests, call_tests, ret);
    return(ret);
}

""")

#
# How to handle a function
# 
nb_tests = 0

def generate_test(module, node):
    global test
    global nb_tests
    nb_cond = 0
    no_gen = 0

    name = node.xpathEval('string(@name)')
    if is_skipped_function(name):
        return

    test.write("""
static int
test_%s(void) {
    int ret = 0;

""" % (name))

    #
    # check we know how to handle the args and return values
    # and store the informations for the generation
    #
    try:
	args = node.xpathEval("arg")
    except:
        args = []
    t_args = []
    n = 0
    for arg in args:
        n = n + 1
        rtype = arg.xpathEval("string(@type)")
	if rtype == 'void':
	    break;
	info = arg.xpathEval("string(@info)")
	nam = arg.xpathEval("string(@name)")
        type = type_convert(rtype, nam, info, module, name, n)
	if is_known_param_type(type) == 0:
	    add_missing_type(type, name);
	    no_gen = 1
	t_args.append((nam, type, rtype, info))
    
    try:
	rets = node.xpathEval("return")
    except:
        rets = []
    t_ret = None
    for ret in rets:
        rtype = ret.xpathEval("string(@type)")
	info = ret.xpathEval("string(@info)")
        type = type_convert(rtype, 'return', info, module, name, 0)
	if rtype == 'void':
	    break
	if is_known_return_type(type) == 0:
	    add_missing_type(type, name);
	    no_gen = 1
	t_ret = (type, rtype, info)
	break

    if no_gen == 1:
	test.write("""
    /* missing type support */
    return(ret);
}

""")
        return

    try:
	conds = node.xpathEval("cond")
	for cond in conds:
	    test.write("#ifdef %s\n" % (cond.get_content()))
	    nb_cond = nb_cond + 1
    except:
        pass
    
    # Declare the memory usage counter
    no_mem = is_skipped_memcheck(name)
    if no_mem == 0:
	test.write("    int mem_base;\n");

    # Declare the return value
    if t_ret != None:
        test.write("    %s ret_val;\n" % (t_ret[1]))

    # Declare the arguments
    for arg in t_args:
        (nam, type, rtype, info) = arg;
	# add declaration
	test.write("    %s %s; /* %s */\n" % (rtype, nam, info))
	test.write("    int n_%s;\n" % (nam))
    test.write("\n")

    # Cascade loop on of each argument list of values
    for arg in t_args:
        (nam, type, rtype, info) = arg;
	#
	test.write("    for (n_%s = 0;n_%s < gen_nb_%s;n_%s++) {\n" % (
	           nam, nam, type, nam))
    
    # log the memory usage
    if no_mem == 0:
	test.write("        mem_base = xmlMemBlocks();\n");

    # prepare the call
    i = 0;
    for arg in t_args:
        (nam, type, rtype, info) = arg;
	#
	test.write("        %s = gen_%s(n_%s, %d);\n" % (nam, type, nam, i))
	i = i + 1;

    # do the call, and clanup the result
    if t_ret != None:
	test.write("\n        ret_val = %s(" % (name))
	need = 0
	for arg in t_args:
	    (nam, type, rtype, info) = arg
	    if need:
	        test.write(", ")
	    else:
	        need = 1
	    test.write("%s" % nam);
	test.write(");\n")
	if extra_post_call.has_key(name):
	    test.write("        %s\n"% (extra_post_call[name]))
	test.write("        desret_%s(ret_val);\n" % t_ret[0])
    else:
	test.write("\n        %s(" % (name));
	need = 0;
	for arg in t_args:
	    (nam, type, rtype, info) = arg;
	    if need:
	        test.write(", ")
	    else:
	        need = 1
	    test.write("%s" % nam)
	test.write(");\n")
	if extra_post_call.has_key(name):
	    test.write("        %s\n"% (extra_post_call[name]))

    test.write("        call_tests++;\n");

    # Free the arguments
    i = 0;
    for arg in t_args:
        (nam, type, rtype, info) = arg;
	#
	test.write("        des_%s(n_%s, %s, %d);\n" % (type, nam, nam, i))
	i = i + 1;

    test.write("        xmlResetLastError();\n");
    # Check the memory usage
    if no_mem == 0:
	test.write("""        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %%d blocks found in %s",
	           xmlMemBlocks() - mem_base);
	    ret++;
""" % (name));
	for arg in t_args:
	    (nam, type, rtype, info) = arg;
	    test.write("""            printf(" %%d", n_%s);\n""" % (nam))
	test.write("""            printf("\\n");\n""")
	test.write("        }\n")

    for arg in t_args:
	test.write("    }\n")

    #
    # end of conditional
    #
    while nb_cond > 0:
        test.write("#endif\n")
	nb_cond = nb_cond -1

    nb_tests = nb_tests + 1;

    test.write("""
    function_tests++;
    return(ret);
}

""")
    
#
# Generate all module callers
#
for module in modules:
    # gather all the functions exported by that module
    try:
	functions = ctxt.xpathEval("/api/symbols/function[@file='%s']" % (module))
    except:
        print "Failed to gather functions from module %s" % (module)
	continue;

    # iterate over all functions in the module generating the test
    for function in functions:
        generate_test(module, function);

    # header
    test.write("""static int
test_%s(void) {
    int ret = 0;

    printf("Testing %s ...\\n");
""" % (module, module))

    # iterate over all functions in the module generating the call
    for function in functions:
        name = function.xpathEval('string(@name)')
	if is_skipped_function(name):
	    continue
	test.write("    ret += test_%s();\n" % (name))

    # footer
    test.write("""
    if (ret != 0)
	printf("Module %s: %%d errors\\n", ret);
    return(ret);
}
""" % (module))

print "Generated test for %d modules and %d functions" %(len(modules), nb_tests)
nr1 = 0
miss1 = 'none'
nr2 = 0
miss2 = 'none'
nr3 = 0
miss3 = 'none'
for missing in missing_types.keys():
    if missing == 'xmlAttrPtr' or missing == 'xmlNsPtr' or missing == '...':
        continue;
    n = len(missing_types[missing])
    if n > nr1:
        miss3 = miss2
	nr3 = nr2
        miss2 = miss1
	nr2 = nr1
        miss1 = missing
	nr1 = n
    elif n > nr2:
        miss3 = miss2
	nr3 = nr2
        miss2 = missing
	nr2 = n
    elif n > nr3:
        miss3 = missing
	nr3 = n

if nr1 > 0:
    print "most needed type support: %s %d times, %s %d and %s %d" % (
          miss1, nr1, miss2, nr2, miss3, nr3)
    print "%d missing types: %s" % (len(missing_types.keys()),
                                    missing_types.keys())

print missing_types[miss1]


